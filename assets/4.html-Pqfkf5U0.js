import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,e as t}from"./app-BORy5ehh.js";const e={},p=t(`<h2 id="如何使用gorilla-mux-的-handler方法" tabindex="-1"><a class="header-anchor" href="#如何使用gorilla-mux-的-handler方法"><span>如何使用gorilla/mux 的 Handler方法</span></a></h2><p>func (r *Router) Handler(method, path string, handler http.Handler) 是 Router 结构体的一个方法，用于将一个 http.Handler 添加到路由中。</p><p>具体来说，它接受三个参数：</p><ul><li>method 是一个字符串，表示 HTTP 方法，比如 &quot;GET&quot;、&quot;POST&quot;、&quot;PUT&quot; 等等。如果要匹配所有方法，可以使用 &quot;*&quot;。</li><li>path 是一个字符串，表示要匹配的 URL 路径。可以包含参数，比如 &quot;/users/:id&quot;。</li><li>handler 是一个 http.Handler，表示要执行的处理器函数。</li></ul><p>当请求到达路由器时，路由器将会匹配请求的方法和路径，如果匹配成功，就会执行相应的处理器函数。如果请求的方法或路径不匹配，路由器将会尝试下一个路由规则。</p><p>下面是一个例子：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;fmt&quot;</span>
    <span class="token string">&quot;net/http&quot;</span>

    <span class="token string">&quot;github.com/gorilla/mux&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    r<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">&quot;/hello/{name}&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vars <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Vars</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        name <span class="token operator">:=</span> vars<span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello, %s!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">)</span>

    r<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token string">&quot;POST&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:8080&quot;</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个新的 mux.Router 实例，并使用 HandleFunc 和 Handler 方法分别添加了两个路由规则。第一个路由规则使用 HandleFunc 方法添加，它将会匹配所有的 GET 请求，路径为 &quot;/hello/{name}&quot;，并执行一个处理器函数，该函数会从请求 URL 中获取名字参数，并将字符串 &quot;Hello, {name}!&quot; 写入响应体中。</p><p>第二个路由规则使用 Handler 方法添加，它将会匹配所有的 POST 请求，路径为 &quot;/hello&quot;，并执行一个匿名函数，该函数将字符串 &quot;Hello, World!&quot; 写入响应体中。</p><h2 id="如何使用httprouter包的-handler-方法" tabindex="-1"><a class="header-anchor" href="#如何使用httprouter包的-handler-方法"><span>如何使用httprouter包的 Handler 方法</span></a></h2><p>httprouter 包中也有一个 Handler 方法，用于将一个 http.Handler 添加到路由中，其函数签名与 gorilla/mux 中的 Handler 方法一致。</p><p>具体来说，它接受三个参数：</p><ul><li>method 是一个字符串，表示 HTTP 方法，比如 &quot;GET&quot;、&quot;POST&quot;、&quot;PUT&quot; 等等。如果要匹配所有方法，可以使用 &quot;*&quot;。</li><li>path 是一个字符串，表示要匹配的 URL 路径。可以包含参数，比如 &quot;/users/:id&quot;。</li><li>handler 是一个 http.Handler，表示要执行的处理器函数。</li></ul><p>当请求到达路由器时，路由器将会匹配请求的方法和路径，如果匹配成功，就会执行相应的处理器函数。如果请求的方法或路径不匹配，路由器将会尝试下一个路由规则。</p><p>下面是一个例子：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;fmt&quot;</span>
    <span class="token string">&quot;net/http&quot;</span>

    <span class="token string">&quot;github.com/julienschmidt/httprouter&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> httprouter<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">&quot;/hello/:name&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">,</span> ps httprouter<span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">:=</span> ps<span class="token punctuation">.</span><span class="token function">ByName</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello, %s!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    r<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token string">&quot;POST&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:8080&quot;</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个新的 httprouter.Router 实例，并使用 GET 和 Handler 方法分别添加了两个路由规则。第一个路由规则使用 GET 方法添加，它将会匹配所有的 GET 请求，路径为 &quot;/hello/{name}&quot;，并执行一个处理器函数，该函数会从请求 URL 中获取名字参数，并将字符串 &quot;Hello, {name}!&quot; 写入响应体中。</p><p>第二个路由规则使用 Handler 方法添加，它将会匹配所有的 POST 请求，路径为 &quot;/hello&quot;，并执行一个匿名函数，该函数将字符串 &quot;Hello, World!&quot; 写入响应体中。</p><p>注意，httprouter 中的路由规则匹配顺序是按照添加的顺序进行的，因此更具体的规则需要放在前面，否则可能会被更通用的规则所覆盖。</p><h2 id="r-httprouter-new-之后为什么就能使用-r-get函数和r-handler函数了" tabindex="-1"><a class="header-anchor" href="#r-httprouter-new-之后为什么就能使用-r-get函数和r-handler函数了"><span>r := httprouter.New()之后为什么就能使用 r.GET函数和r.Handler函数了？</span></a></h2><p>在 httprouter 包中，New 函数返回了一个 httprouter.Router 类型的实例，该实例具有多个方法，包括 GET 和 Handler 方法。</p><p>这是因为 httprouter.Router 类型实现了 http.Handler 接口，因此可以将其作为参数传递给 http.ListenAndServe 函数，从而处理传入的 HTTP 请求。</p><p>在 httprouter 中，路由器的处理方式与标准库中的 http.ServeMux 类似，都是将路由规则映射到处理器函数。但是，httprouter 采用了一些性能优化措施，例如使用 Trie 树来快速匹配路由规则，以提高路由匹配的速度和效率。</p><p>因此，当你调用 r.GET 或 r.Handler 函数时，实际上是将一个路由规则添加到 httprouter.Router 实例中。当请求到达路由器时，路由器将会根据路由规则匹配请求的方法和路径，并调用相应的处理器函数来处理请求。</p>`,24),o=[p];function l(u,i){return a(),s("div",null,o)}const d=n(e,[["render",l],["__file","4.html.vue"]]),k=JSON.parse('{"path":"/posts/go/4.html","title":"如何使用func (r *Router) Handler(method, path string, handler http.Handler)","lang":"zh-CN","frontmatter":{"title":"如何使用func (r *Router) Handler(method, path string, handler http.Handler)","icon":"edit","date":"2023-06-06T00:13:46.000Z","category":["Go 语言"],"tag":["golang"],"description":"如何使用gorilla/mux 的 Handler方法 func (r *Router) Handler(method, path string, handler http.Handler) 是 Router 结构体的一个方法，用于将一个 http.Handler 添加到路由中。 具体来说，它接受三个参数： method 是一个字符串，表示 HTTP ...","head":[["meta",{"property":"og:url","content":"https://jiejaitt.tech/posts/go/4.html"}],["meta",{"property":"og:title","content":"如何使用func (r *Router) Handler(method, path string, handler http.Handler)"}],["meta",{"property":"og:description","content":"如何使用gorilla/mux 的 Handler方法 func (r *Router) Handler(method, path string, handler http.Handler) 是 Router 结构体的一个方法，用于将一个 http.Handler 添加到路由中。 具体来说，它接受三个参数： method 是一个字符串，表示 HTTP ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-14T02:11:56.000Z"}],["meta",{"property":"article:author","content":"JIeJaitt"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:published_time","content":"2023-06-06T00:13:46.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-14T02:11:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何使用func (r *Router) Handler(method, path string, handler http.Handler)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-06T00:13:46.000Z\\",\\"dateModified\\":\\"2023-06-14T02:11:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JIeJaitt\\",\\"url\\":\\"https://jiejaitt.tech\\"}]}"]]},"headers":[{"level":2,"title":"如何使用gorilla/mux 的 Handler方法","slug":"如何使用gorilla-mux-的-handler方法","link":"#如何使用gorilla-mux-的-handler方法","children":[]},{"level":2,"title":"如何使用httprouter包的 Handler 方法","slug":"如何使用httprouter包的-handler-方法","link":"#如何使用httprouter包的-handler-方法","children":[]},{"level":2,"title":"r := httprouter.New()之后为什么就能使用 r.GET函数和r.Handler函数了？","slug":"r-httprouter-new-之后为什么就能使用-r-get函数和r-handler函数了","link":"#r-httprouter-new-之后为什么就能使用-r-get函数和r-handler函数了","children":[]}],"git":{"createdTime":1686064636000,"updatedTime":1686708716000,"contributors":[{"name":"JIeJaitt","email":"498938874@qq.com","commits":2}]},"readingTime":{"minutes":3.81,"words":1144},"filePathRelative":"posts/go/4.md","localizedDate":"2023年6月6日","excerpt":"<h2>如何使用gorilla/mux 的 Handler方法</h2>\\n<p>func (r *Router) Handler(method, path string, handler http.Handler) 是 Router 结构体的一个方法，用于将一个 http.Handler 添加到路由中。</p>\\n<p>具体来说，它接受三个参数：</p>\\n<ul>\\n<li>method 是一个字符串，表示 HTTP 方法，比如 \\"GET\\"、\\"POST\\"、\\"PUT\\" 等等。如果要匹配所有方法，可以使用 \\"*\\"。</li>\\n<li>path 是一个字符串，表示要匹配的 URL 路径。可以包含参数，比如 \\"/users/:id\\"。</li>\\n<li>handler 是一个 http.Handler，表示要执行的处理器函数。</li>\\n</ul>","autoDesc":true}');export{d as comp,k as data};
