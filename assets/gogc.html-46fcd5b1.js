const t=JSON.parse('{"key":"v-0b7d16a3","path":"/posts/go/gogc.html","title":"Go语言垃圾回收","lang":"zh-CN","frontmatter":{"title":"Go语言垃圾回收","icon":"edit","date":"2022-06-10T15:16:14.000Z","category":["Go 语言"],"tag":["golang"],"description":"Go语言中使用的垃圾回收使用的是标记清扫算法。进行垃圾回收时会 stoptheworld。不过在Go语言 1.3 版本中，实现了精确的垃圾回收和并行的垃圾回收，大大地提高了垃圾回收的速度，进行垃圾回收时系统并不会长时间卡住。 标记清扫算法 标记清扫算法是一个很基础的垃圾回收算法，该算法中有一个标记初始的 root 区域，以及一个受控堆区。root 区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。 判断一个对象是否为垃圾，就是看从 root 区域的对象是否有直接或间接的引用到这个对象。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收掉。","head":[["meta",{"property":"og:url","content":"https://jiejaitt.tech/posts/go/gogc.html"}],["meta",{"property":"og:title","content":"Go语言垃圾回收"}],["meta",{"property":"og:description","content":"Go语言中使用的垃圾回收使用的是标记清扫算法。进行垃圾回收时会 stoptheworld。不过在Go语言 1.3 版本中，实现了精确的垃圾回收和并行的垃圾回收，大大地提高了垃圾回收的速度，进行垃圾回收时系统并不会长时间卡住。 标记清扫算法 标记清扫算法是一个很基础的垃圾回收算法，该算法中有一个标记初始的 root 区域，以及一个受控堆区。root 区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。 判断一个对象是否为垃圾，就是看从 root 区域的对象是否有直接或间接的引用到这个对象。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收掉。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-14T02:11:56.000Z"}],["meta",{"property":"article:author","content":"JIeJaitt"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:published_time","content":"2022-06-10T15:16:14.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-14T02:11:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go语言垃圾回收\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-10T15:16:14.000Z\\",\\"dateModified\\":\\"2023-06-14T02:11:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JIeJaitt\\",\\"url\\":\\"https://jiejaitt.tech\\"}]}"]]},"headers":[{"level":2,"title":"标记清扫算法","slug":"标记清扫算法","link":"#标记清扫算法","children":[]},{"level":2,"title":"位图标记和内存布局","slug":"位图标记和内存布局","link":"#位图标记和内存布局","children":[]},{"level":2,"title":"精确的垃圾回收","slug":"精确的垃圾回收","link":"#精确的垃圾回收","children":[]},{"level":2,"title":"基本的标记过程","slug":"基本的标记过程","link":"#基本的标记过程","children":[]},{"level":2,"title":"并行的垃圾回收","slug":"并行的垃圾回收","link":"#并行的垃圾回收","children":[]},{"level":2,"title":"垃圾回收的时机","slug":"垃圾回收的时机","link":"#垃圾回收的时机","children":[]}],"git":{"createdTime":1686703609000,"updatedTime":1686708716000,"contributors":[{"name":"JIeJaitt","email":"498938874@qq.com","commits":2}]},"readingTime":{"minutes":15.02,"words":4505},"filePathRelative":"posts/go/gogc.md","localizedDate":"2022年6月10日","excerpt":"<p>Go语言中使用的垃圾回收使用的是标记清扫算法。进行垃圾回收时会 stoptheworld。不过在Go语言 1.3 版本中，实现了精确的垃圾回收和并行的垃圾回收，大大地提高了垃圾回收的速度，进行垃圾回收时系统并不会长时间卡住。</p>\\n<h2> 标记清扫算法</h2>\\n<p>标记清扫算法是一个很基础的垃圾回收算法，该算法中有一个标记初始的 root 区域，以及一个受控堆区。root 区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。</p>\\n<p>判断一个对象是否为垃圾，就是看从 root 区域的对象是否有直接或间接的引用到这个对象。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收掉。</p>","autoDesc":true}');export{t as data};
